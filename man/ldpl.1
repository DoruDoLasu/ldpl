.TH LDPL 1 "5 may 2019" "LDPL Man 1.0"

.SH NAME
ldpl - The LDPL programming language compiler

.SH SYNOPSIS
.PP
ldpl [-i=<extension file>]... <source file>|-c
     [-o=<output name>|-r] [-f=<c++ flag>]... [-n]
.br
ldpl [-v|-h]

For more information on these options you can run "ldpl -h".

.SH DESCRIPTION
.PP
This program compiles LDPL source code into executable binaries.
LDPL is a programming language designed from the ground up to be excessively expressive, fast, readable and easy to learn.
In order to be able to properly compile LDPL executables you
.I
must
have a valid C++ compiler on your $PATH linked to the name 'c++'.

Documentation and reference for the LDPL Programming Language can be found in the sections below.

.SH OPTIONS
.PP
-v, --version
    Print out LDPL version info and release details.

-h, --help
    Print this list of options.

-r
    By using -r you can just compile the project and print the C++ representation for that code.

-o=<name>
    You can set the output file for the compiled binary with the -o flag. For example, if you want to name your program "dog", you could compile it with ldpl -o=dog main.ldpl.

-i=<file>
    Extensions can be imported by using this flag; see the Extensions section.

-f=<flag>
    The -f flag can be used to add flags to the C++ compilation line. See the Building C++ Extensions section for more information.

-n, --non-static
    On Linux and Windows platforms, LDPL builds static binaries by default. If you want to build non-static ones use the -ns flag. To build on Android Termux you must use this flag.

-c
    The -c flag tells LDPL to accept source code from the standard input.

.SH AUTHOR
This document is based on the LDPL Reference, written by Martín del Río in collaboration with dvkt.

.SH REPORTING BUGS
Report any bugs to <https://github.com/lartu/ldpl>.

.SH COPYRIGHT
Copyright © 2018 - 2019, Martín del Río. LDPL may be copied only under the terms of the GNU General Public License 3.0, which may be found in the LDPL repository.
.br
This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.

.ce 1
.SH -=-=-=-=-=-=-=-=-=- DOCS: LDPL DOCUMENTATION -=-=-=-=-=-=-=-=-=-


.SH INTRODUCTION

The LDPL Community has compiled this document with the desire to teach and standardize the LDPL programming language.


Feedback, corrections and suggestions are welcome, both on the main LDPL repository or by e-mail to mdelrio (at) dc.uba.ar. You can join the LDPL community at r/ldpl or via IRC on irc.freenode.net channel \#ldpl.

This reference can be forked on GitHub.



.SH ABOUT LDPL

.B What is LDPL?


LDPL (Lartu's Definitive Programming Language) is a programming language designed from the ground up to be excessively expressive, fast, readable and easy to learn. It mimics English in the likeness of the good parts of older languages like COBOL, with the desire that it can be understood by anybody. It's highly portable and runs on a plethora of different architectures and operating systems including AMD-64, ARMv8 and PowerPC Linux and Mac OS X. It also supports UTF-8 out of the box.

1 | data:
.br
2 |   name is text     # Your name goes here!
.br
3 | 
.br
4 | procedure:
.br
5 |   display "Hello World" crlf "What's your name? "
.br
6 |   accept name
.br
7 |   display "你好, " name "! Welcome to LDPL!" crlf
.br

LDPL also aims to suppress unreadable code and redundancy by only having one way of doing everything. What a command does should never overlap with the purpose of another and, as such, every LDPL command does one and only one thing. Every line is a step further towards the completion of an algorithm, no more, no less.



.SH FILE EXTENSIONS

The preferred file extension for LDPL source files is '.ldpl'. The alternative '.lsc' (LDPL Source Code) should also be accepted if the later interfered with existing file extensions.

-- Note:
.br
File extensions are important: they tell editors how to recognize your source code and the compiler how to treat your files.
.br
--



.SH USING THE LDPL COMPILER

To use LDPL, you should first download or compile the LDPL compiler.

To use the compiler, you must have a C++ compiler already installed on your system and have mapped it to 'c++', found on your 'PATH'. The LDPL Compiler compiles LDPL code to C++ code and thus this is a requirement for it to work.

.br
[*] If you want to download a compiled binary: download the latest stable release available. You should then move the binary to a folder on your PATH.
.br
[*] If you want to build LDPL yourself: first, clone this repository. Then 'make' and 'make install' LDPL in the 'src' folder. This will install LDPL and the LDPL documentation ('man ldpl') on your system. LDPL requires only C++11 to compile.

When you are done installing LDPL, write some LDPL source code, say 'source.ldpl'. Then compile the source code using 'ldpl source.ldpl'. The compiled, executable binary file will be saved as 'ldpl-bin'. Done! For more info on the compiler run 'ldpl -h'. Example code can be found on the LDPL website.

{% hint style="danger
.br
Please note that Windows support has been dropped as of LDPL 4.0.
.br
--



.SH LDPL COMPILER SWITCHES

To compile an LDPL source file, the syntax is as follow:

'$ ldpl <ldpl_source_file> [[-i=]<ldpl_source_file>]* [flag]*'

The first part of the command, 'ldpl' runs the LDPL compiler. Then it checks every other part of the command for either files or compiler flags. Compiler flags are preceded by '-' or '--', all the remaining tokens are considered to be files to be compiled. Except when importing source files (more on this below), the order of the parameters of the compilation line doesn't really matter.

You can pass the LDPL compiler as many source files as you want and all these files will be compiled into one big executable, respecing the order in which they were passed to the compiler. For example, if you have three scripts 'helloWorld.ldpl' (that prints "Hello World!" when executed), 'byeByeWorld.ldpl' (that prints "Bye Bye World!") when executed, and 'hiThere.ldpl' (that prints "Hi there~" when executed), you could compile all three files into one single executable by running

'$ ldpl helloWorld.ldpl byeByeWorld.ldpl hiThere.ldpl'

and this would create an executable file called 'helloWorld-bin'. By default, the name used to save the executable is the name of the first LDPL source code passed to the compiler, minus the extension, plus '-bin'.

When you run 'helloWorld-bin', "Hello World! Bye Bye World! Hi there~" will be printed to the screen, respecting the order in which the sources where compiled. If you were to change the order of the sources in the compilation line, the order of execution of the binary file would change as well.

Flags alter the way the compiler works by default. The list of available flags can be found by running '$ ldpl -h'.

You can import extensions to your LDPL compilation by using the '-i=' flag. Extensions can be imported by passing '.o', '.a', or '.cpp' files to this flag. Multiple '-i=' can be used to import multiple files. See the Extensions section for more information.

By using the '-r' flag you can just transpile the project into C++ and print the C++ representation for that code.

You can set the output file name for the compiled binary with the '-o' flag. For example, if in the example above you wanted to name your program "myProgram" instead of "helloWorld-bin", you could compile it with 'ldpl main.ldpl -o=myProgram'.

On Linux platforms, LDPL builds static binaries by default. If you want to build non-static ones use the '-ns' flag.

The '-c' flag tells LDPL to accept source code from the standard input.

'-v' and '--version' print out version info and release details.

'-h' and '--help' print this list of options.

The '-f' flag can be used to add flags to the C++ compilation line. See the Building C++ Extensions section for more information.



.SH STRUCTURE OF LDPL SOURCE CODE

LDPL was designed to be a rigidly structured programming language and, as such, variable declarations and the rest of the code procedure are separated in two different, mutually exclusive sections within a source file. Variable declarations should be placed within the DATA section, while the rest of the code should be placed inside the PROCEDURE section. Further subprocedures should be placed also within the PROCEDURE section, inside their own SUB-PROCEDURE subsection.

Bearing this in mind, the basic skeleton of a LDPL source code will look like this:

1 | DATA:
.br
2 | 
.br
3 | PROCEDURE:
.br
4 | 
.br

Every statement in LDPL has to be on its own line. Thus, statements are separated by line breaks and it's not possible to have two statements on the same line.

-- Note:
.br
The DATA section can be obviated if no variables are declared.
.br
--



.SH COMMENTS IN LDPL

Comments in LDPL are denoted with a hash symbol ('\#') and can be placed both on their own line or at the end of a line that already contains a statement. Everything after the hash is considered to be part of the comment and, therefore, not executed nor compiled.

1 | DATA: #This is the DATA section
.br
2 | 
.br
3 | PROCEDURE:
.br
4 |   #This is a comment within the PROCEDURE section!
.br





.SH DATA SECTION

As stated in Structure of LDPL Source Code, LDPL programs are divided in two sections, one of them being the DATA section. The DATA section is where global variables are declared (you can use them anywhere in your program). If no variables are declared, the DATA section can be skipped altogether.

All variables in LDPL have a defined data type.

-- Note:
.br
Available data types are 'NUMBER', 'TEXT', 'NUMBER LIST', 'TEXT LIST', 'NUMBER MAP' and 'TEXT MAP'.
.br
--

The DATA section is defined and preceded by the 'DATA:' keyword. An empty data section looks like this:

1 | DATA:
.br

On every line within the DATA section (that is, on every line after the 'DATA:' keyword and before the 'PROCEDURE:' keyword) one and only one variable can be declared.

The syntax for declaring a variable in LDPL is:

1 | variable name IS data type
.br

-- Note:
.br
Variable names should follow the rules stated here.
.br
--

A DATA section cannot contain anything but variable declarations, comments and empty lines. En example DATA section may end up looking like this:

1 | DATA: #This is the DATA section
.br
2 |   myNumber IS NUMBER
.br
3 |   #Next I'm going to declare a text map
.br
4 |   niceTextMap IS TEXT MAP
.br
5 |   myAwesomeList IS NUMBER LIST # I've declared a number list!
.br
6 | 
.br
7 | PROCEDURE:
.br
8 |   #This is a comment within the PROCEDURE section!
.br



.SH DATA TYPES

LDPL natively supports the NUMBER and TEXT data types. It also supports VECTORS of values of such types.

The NUMBER data type, as its name suggests, depicts numeric values. It's recommended that it be represented internally as a binary64 double-precision floating-point format number as defined by the IEEE 754.

Both variables and numeric constants can be members of the NUMBER type.

Valid number literals must begin with a decimal value (for example '5' or '0.12', '.12' wouldn't be a valid NUMBER) and may be preceded by a minus sign for negative numbers ('-5', '-567.912'). Numbers may not be preceded by a plus sign ('+5' is not a valid number literal). The literal '-0' is implicitly transformed into '0'.

The TEXT data type, as its name suggests, represents alphanumeric strings. In the interest of supporting as many locales as possible, LDPL should be utf-8 encoded to be compatible with Unicode. A TEXT maximum length is explicitly not defined and it should be limited only by the amount of available memory on the system. Strings in LDPL are enclosed between two '"'quotes'"' and can contain multiple escape sequences.

Both variables and string constants can be members of the TEXT type.

The LIST data type is a collection of NUMBER or TEXT values. Values can be pushed to LISTs and then accessed and modified using the ':' operator. LIST indexes consist of integer numbers. The first index of a LIST is index 0, and the rest count up to the length of the list minus one. LISTs are explained in greater detail in the 'Declaring LIST Variables' section.

LISTs, as collections of NUMBER or TEXT values, can only have one defined type at any given time: TEXT or NUMBER. A single LIST is not capable of storing both numeric and alphanumeric values.

The MAP data type is a collection of NUMBER or TEXT values. MAPs superficially resemble LISTs but with fundamental differences. The biggest one is that any number or string in LDPL may be used as an array index, not just consecutive integers. Also, values in MAPs have no order, so there's no one coming before or after any other. MAPs are explained in greater detail in the 'Declaring MAP Variables' section.

MAPs, as collections of NUMBER or TEXT values, can only have one defined type at any given time: TEXT or NUMBER. A single MAP is not capable of storing both numeric and alphanumeric values.



.SH PROCEDURE SECTION

As stated in Structure of LDPL Source Code, LDPL programs are divided in two sections, one of them being the DATA section, the other being the PROCEDURE section. The PROCEDURE section is where all the code of a LDPL program that is not a variable declaration is written. A LDPL program must contain a PROCEDURE section, even if it's empty. Compilation will fail otherwise. If your program consists of multiple LDPL source files, each file must have its own PROCEDURE section.

Within the PROCEDURE section, every line can contain either a comment, a statement, a statement and a comment or be empty. No two statements can be written on the same line.

1 | PROCEDURE:
.br
2 |   #A comment
.br
3 |   STORE 5 IN myVariable
.br
4 |   STORE 6 IN myOtherVariable #A statement and a comment
.br

Available statements will be explained further in the following sections of this document.

Code within the PROCEDURE section is executed from top to bottom, skipping SUB-PROCEDURE sections, unless explicitly called.



.SH SUB-PROCEDURES

A SUB-PROCEDURE is a piece of code that can be called and executed from other parts of the script. SUB-PROCEDURE subsections must be declared within the PROCEDURE section of the code using a 'SUB-PROCEDURE <name>' statement and end with an 'END SUB-PROCEDURE' statement. Bear in mind that you can't define a SUB-PROCEDURE within a SUB-PROCEDURE. Also bear in mind that you can CALL a SUB-PROCEDURE before it has been declared, but the compilation process will fail if the compiler doesn't find the SUB-PROCEDURE once it has parsed all the files in your program.

The full syntax for declaring sub-procedures is this one:

1 | SUB-PROCEDURE procedureName
.br
2 |     PARAMETERS:
.br
3 |         < parameters go here >
.br
4 |     LOCAL DATA:
.br
5 |         < local variable declarations go here >
.br
6 |     PROCEDURE:
.br
7 |         < code goes here >
.br
8 | END SUB-PROCEDURE
.br

The 'PARAMETERS:' and 'LOCAL DATA:' sub-sections are optional (more on these later). If you decide to not include both the 'PARAMETERS:' and 'LOCAL DATA:' sub-sections, you can skip the 'PROCEDURE:' tag and just go ahead writing your code like this:

1 | SUB mySub
.br
2 |     # Your code goes here! For example
.br
3 |     DISPLAY "I love sub-procedures!" crlf
.br
4 | END SUB
.br

As shown in the example above, the statements 'SUB' and 'END SUB' can be used instead of 'SUB-PROCEDURE' and 'END SUB-PROCEDURE', if you prefer.

In context, the full declaration of a SUB-PROCEDURE looks like this:

1 | DATA:
.br
2 |   # ...
.br
3 | PROCEDURE:
.br
4 |   # ...
.br
5 |   SUB-PROCEDURE mySubprocedure
.br
6 |     PARAMETERS:
.br
7 |         # Parameters declaration
.br
8 |     LOCAL DATA:
.br
9 |         # Local variables declaration
.br
10|     PROCEDURE:
.br
11|         # Sub procedure code
.br
12|         # goes here.
.br
13|   END SUB-PROCEDURE
.br

Of course, you cannot have two SUB-PROCEDUREs with the same name. SUB-PROCEDURE names follow the same naming guidelines variable names follow.

SUB-PROCEDUREs have three sub-sections: 'PARAMETERS:', 'LOCAL DATA:' and 'PROCEDURE:'. Again, the first two sub-sections are optional and only 'PROCEDURE:' is mandatory, but you can skip the 'PROCEDURE:' label if you only use this section, like this:

1 | DATA:
.br
2 |   # ...
.br
3 | PROCEDURE:
.br
4 |   # ...
.br
5 |   SUB-PROCEDURE mySubprocedure
.br
6 |     # Sub procedure code
.br
7 |     # goes here.
.br
8 |   END SUB-PROCEDURE
.br

In the 'PROCEDURE:' sub-section, you write the code of the SUB-PROCEDURE using statements like in the main 'PROCEDURE:' section, with the addition of the RETURN statement.

In 'PARAMETERS:' and 'LOCAL DATA:' you can only use variable declaration statements, just like in the DATA section. The variables defined here can only be used inside the 'PROCEDURE:' sub-section of the SUB-PROCEDURE where they are declared; you can declare variables with names declared in other SUB-PROCEDURE or in the main 'DATA:' section, but bear in mind that if you use these variables in your SUB-PROCEDURE code, they will always refer to the ones you declared within the SUB-PROCEDURE. For example:

1 | DATA:
.br
2 |   i IS number
.br
3 | PROCEDURE:
.br
4 |   SUB-PROCEDURE mySubprocedure
.br
5 |     LOCAL DATA:
.br
6 |         i IS text
.br
7 |     PROCEDURE:
.br
8 |         STORE "I'm a variable from mySubprocedure! " IN i
.br
9 |         DISPLAY i
.br
10|   END SUB-PROCEDURE
.br
11| 
.br
12|   STORE 42 IN i
.br
13|   CALL mySubprocedure
.br
14|   DISPLAY i
.br
15|   # The output of this program is "I'm a variable from mySubprocedure! 42"
.br

At the start of the SUB-PROCEDURE execution, all the variables declared in 'LOCAL DATA:' will be initialized with its default value, and each invocation of the SUB-PROCEDURE will have its own copy of the local variables. This is important if you want to implement a recursive SUB-PROCEDURE, for example:

1 | DATA:
.br
2 |   executions IS number
.br
3 | PROCEDURE:
.br
4 |   SUB-PROCEDURE myRecursiveSubprocedure
.br
5 |     LOCAL DATA:
.br
6 |         myLocalVar IS number
.br
7 |     PROCEDURE:
.br
8 |         INCR executions
.br
9 |         IF executions IS EQUAL TO 3 THEN
.br
10|             RETURN  # We don't want this to run forever!
.br
11|         END IF
.br
12|         DISPLAY "[myLocalVar starts at " myLocalVar "!"
.br
13|         STORE executions IN myLocalVar
.br
14|         CALL myRecursiveSubprocedure
.br
15|         DISPLAY "I'm execution Nº " myLocalVar "!]"
.br
16|   END SUB-PROCEDURE
.br
17| 
.br
18|   CALL myRecursiveSubprocedure
.br
19|   # The output of this program is
.br
20|   # "[myLocalVar starts at 0![myLocalVar starts at 0!I'm execution Nº 2!]I'm execution Nº 1!]"
.br

Variables declared in 'PARAMETERS:' are quite different, they will start with the value passed from the CALL using the 'WITH' keyword. Variables are passed by reference. This means that if you modify a parameter in a SUB-PROCEDURE, the variable passed in the 'CALL' will also be modified. Be careful with this, and make sure to copy a parameter in a local variable if you need it. Passing variables by reference lets you return results from your SUB-PROCEDURE, for example:

1 | DATA:
.br
2 |   i IS number
.br
3 | PROCEDURE:
.br
4 |   SUB-PROCEDURE duplicate
.br
5 |     PARAMETERS:
.br
6 |         input IS number
.br
7 |         result IS number
.br
8 |     PROCEDURE:
.br
9 |         IN result solve input + input
.br
10|   END SUB-PROCEDURE
.br
11| 
.br
12|   CALL duplicate WITH 2 i
.br
13|   DISPLAY i
.br
14|   # The output of this program is "4"
.br



.SH IMPORTING OTHER SOURCES

You can import other LDPL source codes to your LDPL source by using the 'INCLUDE' statement. For example, say you have two sources:

File: firstSource.ldpl
.br
1 | procedure:
.br
2 |   call someSubprocedure
.br


and

File: included.ldpl
.br
1 | procedure:
.br
2 |   sub someSubprocedure
.br
3 |     display "Hi there!"
.br
4 |   end sub
.br


You can import the second source into the first one in order to create one big source file like this:

File: firstSource.ldpl
.br
1 | include "included.ldpl"
.br
2 | procedure:
.br
3 |   call someSubprocedure
.br


The location where the included files are searched is relative to the file that includes them.



.SH VARIABLES IN LDPL

LDPL is not a case sensitive language. Variables called 'myVar' and 'MYVAR' are considered to be the same variable, the same with sub-procedure names and statements of any kind. Variable names must follow the rules stated here.

.B Usage of Variables

In the following sections you will see excerpts of code like this one:

1 | STORE <NUMBER-VAR or NUMBER> IN <NUMBER-VAR>
.br

Notice the parts in between less-than and greater-than symbols ('<like this>'). Parts of procedures stylized like that mean that they should be replaced by whatever they say inside. In the example above, the first replaceable part can be substituted with the name of a variable of NUMBER type or by a NUMBER constant.

Available replacement values are:

.br
[*] 'NUMBER': A constant of type NUMBER.
.br
[*] 'TEXT': A constant of type TEXT.
.br
[*] 'NUMBER-VAR': A variable of type NUMBER.
.br
[*] 'TEXT-VAR': A variable of type TEXT.
.br
[*] 'SUB-NAME': A name of a sub-procedure.



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH DECLARING LIST VARIABLES

A LIST is a sequence of values, called elements. The elements of a LIST are distinguished by their indices. Indices are NUMBER literals that start at 0 (the first element of the list) and grow up to the length of the list minus one (the last element of the list). LISTs in LDPL are variables that hold a collection of values. When you declare a LIST, you declare a structure that lets you store values of its type one after another. For example, say you declare the list 'myList':

1 | DATA:
.br
2 |   myList IS NUMBER LIST
.br

Then you can use 'myList' as a multi-variable with various indexes where you can store NUMBERs.

LDPL provides one-dimensional LISTs for storing groups of related strings or numbers (but not at the same time: LISTs can be either 'NUMBER LIST' or 'TEXT LIST' and each can only be used to store values of the chosen data type).

In most other languages, you may have to declare a LIST and specify how many elements or components it contains. In such languages, the declaration causes a contiguous block of memory to be allocated for that many elements. LDPL LISTs, however, are different: they are dynamic. This means that you can store as many values as you want in a single LIST without fear of running out of place (of course, this is limited by the memory allocated by your operating system for your LDPL program).

Suppose you store the values '"hi"', '"there"', '"I love"' and '"LDPL, it's great!"' in a 'TEXT LIST', in that particular order. Then the contents of the list and the index associated with each element will be

.br
| Index | Element |
.br
| :---: | :---: |
.br
| 0 | '"hi"' |
.br
| 1 | '"there"' |
.br
| 2 | '"I love"' |
.br
| 3 | '"LDPL, it's great!"' |

We have shown the pairs in order because their order is relevant: if you added a new element to the LIST, it would be inserted after the last element, thus being associated with index '4'.

To add values to a LIST, you must first push them to the list. For example, if you want to add the numbers '10', '20' and '30' to a 'NUMBER LIST', your code should look like this:

1 | DATA:
.br
2 |   myList IS NUMBER LIST
.br
3 | PROCEDURE:
.br
4 |   PUSH 10 TO myList # 10 is stored in index 0 of myList
.br
5 |   PUSH 20 TO myList # 20 is stored in index 1 of myList
.br
6 |   PUSH 30 TO myList # 30 is stored in index 2 of myList
.br

Values in LISTs can be stored and accessed just like any other variable (see the STORE - IN statement for further details) using the ':' operator. This operator indicates what index of the LIST we are writing to or reading from. Here we declare a 'NUMBER LIST' and store the values '5' and '-10.2' in it, and then replace the number '5' by the number '890':

1 | DATA:
.br
2 |   myList IS NUMBER LIST
.br
3 | PROCEDURE:
.br
4 |   PUSH 5 TO myList # 5 is stored in index 0 of myList
.br
5 |   PUSH -10.2 TO myList # -10.2 is stored in index 1 of myList
.br
6 |   STORE 890 IN myList:0 #We store 890 in index 0 of myList, thus replacing the 5
.br

Please note that as a LIST is variable that's a collection of values, a single index of a LIST is a variable in itself. This means that any subindex of a LIST can be used in any position where you could use a variable of the same type of the LIST. So, if you have something like this:

1 | STORE <NUMBER-VAR or NUMBER> IN <NUMBER-VAR>
.br

You could use a 'NUMBER LIST' with a defined sub-index (for example, in the example above, 'myList:0') where it says NUMBER-VAR, just like in the 'STORE - IN' examples in the code extracts above.

In the LIST STATEMENTS section you'll find a collection of statements that can be used to work with LISTs.



.SH DECLARING MAP VARIABLES

A MAP is a table of values, called elements. The elements of a MAP are distinguished by their keys. Keys may be either NUMBER or TEXT literals. MAPs in LDPL are variables that hold a collection of values. When you declare a MAP, you declare a structure that lets you store values of its type on any sub-index of the variable. For example, say you declare the map 'myMap':

1 | DATA:
.br
2 |   myMap IS NUMBER MAP
.br

Then you can use 'myMap' as a multi-variable with various indexes where you can store NUMBERs.

Unlike LISTs, MAPs are associative. This means that each MAP is a collection of pairs: a key and its corresponding element. For example, you could have a 'NUMBER MAP' with the following contents:

.br
| Key | Element |
.br
| :---: | :---: |
.br
| 4 | 30 |
.br
| 2 | 10 |
.br
| "Hi there!" | -56.3 |
.br
| "99ldplrocks89" | 0 |

We have shown the pairs in jumbled order because their order is irrelevant. One advantage of MAPs is that new pairs can be added at any time. MAPs can be sparse: they can have missing keys (say for example you have keys 1 and 5, but don't have keys 2, 3 and 4). Another consequence of MAPs is that the keys don't necessarily have to be positive integers. Any number, or even a string, can be a key.

Values in MAPs can be stored and accessed just like any other variable (see the STORE - IN statement for further details) using the ':' operator. This operator indicates what key of the MAP we are writing to or reading from. Here we declare a 'NUMBER MAP' and store the values '5' and '-10.2' in the keys '1' and '5', respectively.

1 | DATA:
.br
2 |   myMap IS NUMBER MAP
.br
3 | PROCEDURE:
.br
4 |   STORE 5 IN myMap:1 #Stores 5 in key 1 of myMap
.br
5 |   STORE -10.2 IN myMap:5 #Stores -10.2 in key 5 of myMap
.br

As stated before, MAP keys don't always have to be constant NUMBERs. They can also be NUMBER variables, TEXT and TEXT variables, or even sub-indexes of LISTs or elements from other MAPs. For example:

1 | DATA:
.br
2 |   myMap IS NUMBER MAP
.br
3 |   myOtherMap IS NUMBER MAP
.br
4 |   myVar IS NUMBER
.br
5 | 
.br
6 | PROCEDURE:
.br
7 |   STORE 17 IN myVar
.br
8 |   STORE 1 IN myMap:"hello" #Stores 1 in key "hello" of myMap
.br
9 |   STORE 7 IN myMap:myVar #Stores 7 in a key equal to the current value of myVar
.br
10|   STORE 3 IN myMap:myOtherMap:4
.br
11|   #Stores 3 in a key of equal value to the key of myMap with value equal to
.br
12|   #key 4 of myOtherMap
.br

In fact, when you use a NUMBER value as a subindex for a MAP, it is silently casted into a TEXT value. For example, 'myMap:1' will be interpreted (an thus, the same) as 'myMap:"1"'.

Please note that as a MAP is variable that's a collection of values, a single key of a MAP is a variable in itself. This means that any key of a MAP can be used in any position where you could use a variable of the same type of the MAP. So, if you have something like this:

1 | STORE <NUMBER-VAR or NUMBER> IN <NUMBER-VAR>
.br

You could use a 'NUMBER MAP' with a particular key where it says NUMBER-VAR, just like in the 'STORE - IN' examples in the code extracts above (for example 'myMap:"hello"').

When LDPL creates a MAP for you using a built-in statement that automatically inserts values into the MAP, for example the SPLIT built-in statement with a MAP for destination, the keys used will be consecutive integers starting at zero ('0', '1', '2', etc.).

As you'll see in the Default Variable Values section, you can access undeclared keys of a MAP just like if they were declared. See the following example:

1 | DATA:
.br
2 |   myMap IS NUMBER MAP
.br
3 | PROCEDURE:
.br
4 |   DISPLAY myMap:99
.br

In the example above, '0' will be printed and no errors displayed during compilation, even though the key'99' of 'myMap' hasn't been explicitly declared. This is because when you try to access an element that hasn't been declared yet, LDPL declares it for you and initializes it to its type default value.

It's important to note that this very feature is a double-edged weapon. While you can use it to access uninitialized MAP keys, you cannot check if a value exists in a MAP without initializing it if it wasn't there before. Statements like STORE KEY COUNT OF and STORE KEYS OF are provided as means to overcome this situation.

In the MAP STATEMENTS section you'll find a collection of statements that can be used to work with MAPs.

-- Warning:
.br
In older versions of LDPL, MAPs where called VECTORs. Starting from LDPL 3.1.0 Diligent Dreadnoughtus, they have been renamed to reflect the real data structure they represent. While it is still possible to call them VECTORs in code, and legacy code that declares MAPs as VECTORs is and will continue be supported, this nomenclature is deprecated and shouldn't be used anymore.
.br
--



.SH DEFAULT VARIABLE VALUES

In LDPL each variable is initialized with a value by default. This means that when you declare a variable, it will, by default, hold this value until it's changed.

NUMBER variables are initialized with the value '0'. Each element of a NUMBER MAP is a NUMBER variable, and thus also initialized to '0'.

TEXT variables are initialized to the empty string '""'. Same goes to TEXT MAPs, where each element is also initialized to '""'.

LISTs are initialized empty by default and trying to access a non-existing index will result in an error.



.SH COMMAND LINE ARGUMENTS

Every LDPL program comes with a variable declared by default: 'argv', a TEXT LIST. If you pass command line arguments to your LDPL compiled program (running, for example, something like 'myBinary argument1 argument2)', the value stored in the 'argv' list (_argument vector_) will store the values of each argument passed (in this case, '"argument1"' will be stored in 'argv:0' and '"argument2"' in 'argv:1').

-- Note:
.br
Given that 'argv' is a TEXT LIST, the values passed as arguments are always stored as TEXT.
.br
--

Naturally, if no arguments are passed to the program, 'argv' will be empty.



.SH ERRORCODE AND ERRORTEXT

Some LDPL operations may fail when executed. Maybe you tried LOADing a file that wasn't there or getting the ASCII value of a multi-byte emoji. These operations make use of the 'ERRORCODE' and 'ERRORTEXT' variables to tell you if they ran successfully or not.

The 'ERRORCODE' and 'ERRORTEXT' variables come declared by default. Some statements may modify their values to express their results.

The 'ERRORCODE' variable is a NUMBER variable. It will hold the value 0 if the statement ran successfully and any other number if it did not.

The 'ERRORTEXT' variable is a TEXT variable that will be empty if the statement ran successfully. If it did not, it will store a human readable description of what went wrong.

'ERRORCODE' and 'ERRORTEXT' can be read and written like any other LDPL variable.

-- Warning:
.br
When handling ERROR checks, please bear in mind that the content of the 'ERRORTEXT' variable may change in future releases of LDPL. The value stored in 'ERRORCODE', however, will not change and so that's the value that should be used to check whether an operation ran successfully or not.
.br
--





.SH ESCAPE SEQUENCES

LDPL strings can contain multiple escape sequences / control characters in them. Each escape sequence counts as only one character. The available escape sequences are:

.br
[*] '\\a' = alert (bell)
.br
[*] '\\b' = backspace
.br
[*] '\\t' = horizontal tab
.br
[*] '\\n' = newline / line feed
.br
[*] '\\v' = vertical tab
.br
[*] '\\f' = form feed
.br
[*] '\\r' = carriage return
.br
[*] '\\e' = non-standard GCC escape
.br
[*] '\\0' = null byte
.br
[*] '\\\\' = \\ character
.br
[*] '\\"' = " character

For example, the string '"hello,\\nworld"' will be displayed as

1 | hello,
.br
2 | world
.br

when printed to the console.



.SH IDENTIFIER NAMING SCHEMES

.B Variable and SUB-PROCEDURE naming scheme

Variables and SUB-PROCEDURE names follow the same naming rules. These names can't be empty and may consist of any character with few exceptions (listed below). Like statements, variable and SUB-PROCEDURE names in LDPL are not case sensitive.

.br
[*] Variable and SUB-PROCEDURE names cannot contain the character ':', it is used for MAP and LIST accesses.
.br
[*] Variable and SUB-PROCEDURE names cannot contain the character '"', it is used to delimit strings.
.br
[*] Variable and SUB-PROCEDURE names cannot contain spaces.
.br
[*] Variable and SUB-PROCEDURE names cannot be valid numbers.
.br
[*] Variable and SUB-PROCEDURE names cannot contain the character '(' nor the character ')' as these characters are used in mathematical expressions.
.br
[*] Variables and SUB-PROCEDUREs cannot be called 'CRLF', as it is internally turned into '"\\r\\n"'.
.br
[*] Variables and SUB-PROCEDUREs cannot be called '+' nor '-' nor '*' nor '/' as these characters are used in mathematical expressions.

.B LABEL naming scheme

Labels in LDPL can't be empty and may contain any character except spaces and '"'. LABELs can't be named 'CRLF' for the same reasons explained in the section above.

.B External Identifier Naming Scheme

Please refer to this page.



.ce 1
.SH -=-=-=-=- DOCS: CONTROL FLOW STATEMENTS -=-=-=-=-

.SH STORE - IN

The 'STORE' statement assigns a value to a variable.

.B Syntax:

1 | STORE <NUMBER-VAR or NUMBER or TEXT-VAR or TEXT> IN <NUMBER-VAR or TEXT-VAR>
.br

Type Conversion Notes:

If the value to be stored is NUMBER and it's to be stored in a TEXT variable, the value will be converted to text, so '15' will be turned into '"15"'. If the value to be stored is a TEXT value two things can happen. If it contains any non-numeric characters (for example letters, or more than one minus sign or more than one decimal point, for example '"--1.2"' or '"15a"') the conversion will fail and 0 will be stored in the NUMBER variable. If the TEXT contains a proper number, though, for example '"-416.419"' or '"89"' it will be converted to its number equivalent and stored in the variable. If a string literal depicting a number is preceded by leading zeros, these will be trimmed (turning '0005' into '5', '-0002.3' into '-2.3' and '00.23' into '0.23').



.SH IF - IS - THEN

The 'IF' statement evaluates if the condition given by the relational operator between the first and second values is positive. If it is, the code in the positive branch is executed. If it is not, the code in the negative branch is executed (if available). Execution then continues normally.

.B Syntax:

1 | IF <NUMBER-VAR or NUMBER or MAP or LIST> IS <REL-OP-NUM> <NUMBER-VAR or NUMBER or MAP or LIST> THEN
.br
2 |  #Code goes here (positive branch)
.br
3 | ELSE
.br
4 |  #Code goes here (negative branch)
.br
5 | END IF
.br

or

1 | IF <TEXT-VAR or TEXT or MAP or LIST> IS <REL-OP-TEXT> <TEXT-VAR or TEXT or MAP or LIST> THEN
.br
2 |  #Code goes here (positive branch)
.br
3 | ELSE
.br
4 |  #Code goes here (negative branch)
.br
5 | END IF
.br

or

1 | IF <NUMBER-VAR or NUMBER or MAP or LIST> IS <REL-OP-NUM> <NUMBER-VAR or NUMBER or MAP or LIST> THEN
.br
2 |  #Code goes here (positive branch)
.br
3 | END IF
.br

or

1 | IF <TEXT-VAR or TEXT or VECTOR or LIST> IS <REL-OP-TEXT> <TEXT-VAR or TEXT or VECTOR or LIST> THEN
.br
2 |  #Code goes here (positive branch)
.br
3 | END IF
.br

Possible values of 'REL-OP-NUM' (number relational operator):

.br
[*] 'EQUAL TO'
.br
[*] 'NOT EQUAL TO'
.br
[*] 'GREATER THAN'
.br
[*] 'LESS THAN'
.br
[*] 'GREATER THAN OR EQUAL TO'
.br
[*] 'LESS THAN OR EQUAL TO'

Possible values of 'REL-OP-TEXT' (text relational operator):

.br
[*] 'EQUAL TO'
.br
[*] 'NOT EQUAL TO'



.SH ELSE IF - IS - THEN

The 'ELSE IF' statement is equivalent to writing an 'IF' statement inside the 'ELSE' statement of another 'IF' statement, but shorter. Must be used after an IF statement and before 'END IF' or 'ELSE'.

.B Syntax:

All the different 'IF' variants of the IF statement apply, just with 'ELSE' added before them.

.B Example:

1 | DATA:
.br
2 |   name IS TEXT
.br
3 | PROCEDURE:
.br
4 |   STORE "Mike" IN name
.br
5 |   IF name IS equal to "John" THEN
.br
6 |     DISPLAY "Hello there, John!" CRLF
.br
7 |   ELSE IF name IS equal to "Mike" THEN
.br
8 |     DISPLAY "Hello there, Mike!" CRLF
.br
9 |   ELSE IF name IS equal to "Robert" THEN
.br
10|     DISPLAY "Hello there, Robert!" CRLF
.br
11|   ELSE
.br
12|     DISPLAY "I don't know you, " name CRLF
.br
13|   END IF
.br



.SH WHILE - IS - DO

The 'WHILE' statement evaluates if the condition given by the relational operator between the first and second values is positive. While it is, the code between the 'WHILE' and 'REPEAT' statements is repeatedly ran.

.B Syntax:

1 | WHILE <NUMBER-VAR or NUMBER or MAP or LIST> IS <REL-OP-NUM> <NUMBER-VAR or NUMBER or MAP or LIST> DO
.br
2 |  #Code goes here
.br
3 | REPEAT
.br

or

1 | WHILE <TEXT-VAR or TEXT or MAP or LIST> IS <REL-OP-TEXT> <TEXT-VAR or TEXT or MAP or LIST> DO
.br
2 |  #Code goes here
.br
3 | REPEAT
.br

Possible values of 'REL-OP-NUM' (number relational operator):

.br
[*] 'EQUAL TO'
.br
[*] 'NOT EQUAL TO'
.br
[*] 'GREATER THAN'
.br
[*] 'LESS THAN'
.br
[*] 'GREATER THAN OR EQUAL TO'
.br
[*] 'LESS THAN OR EQUAL TO'

Possible values of 'REL-OP-TEXT' (text relational operator):

.br
[*] 'EQUAL TO'
.br
[*] 'NOT EQUAL TO'



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH FOR - FROM - TO - STEP - DO

The 'FOR' statement repeatedly run the code in its body a number of times, given a 'counter' variable, the 'start' of the range, its 'end' and a 'step'.

When the loop starts, 'start' is assigned to 'counter' and starts an iteration, evaluating a condition. The condition is 'counter < end' if 'step >= 0' and 'counter > end' if 'step < 0'. If the condition passes, the code in the body of the 'FOR' is executed, otherwise the loop will end. After the code is ran the 'counter' is incremeted by 'step' and a new iteration is started (checking the condition and so on).

.B Syntax:

1 | FOR <NUMBER-VAR> FROM <NUMBER-VAR or NUMBER> TO <NUMBER-VAR or NUMBER> STEP <NUMBER-VAR or NUMBER> DO
.br
2 |  #Code goes here
.br
3 | REPEAT
.br

.B Example:

1 | DATA:
.br
2 |   i IS NUMBER
.br
3 | PROCEDURE:
.br
4 |   FOR i FROM 0 TO 10 STEP 2 DO
.br
5 |     DISPLAY i " "
.br
6 |   REPEAT
.br
7 |   # Will display "0 2 4 6 8 10"
.br



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH FOR EACH - IN - DO

The 'FOR EACH' statement repeatedly run the code in its body for every element in a given 'LIST' or 'MAP'. At the start of each iteration an element of the collection is assigned to a variable matching its type.

If the collection is a 'LIST', its elements will be iterated increasingly from index '0', while in the case of a 'MAP' all the elements will be iterated in no particular order.

.B Syntax:

1 | FOR EACH <NUMBER-VAR> IN <NUMBER-LIST or NUMBER-MAP> DO
.br
2 |  #Code goes here
.br
3 | REPEAT
.br
4 | FOR EACH <TEXT-VAR> IN <TEXT-LIST or TEXT-MAP> DO
.br
5 |  #Code goes here
.br
6 | REPEAT
.br

.B Example 1:

1 | DATA:
.br
2 |   letter IS TEXT
.br
3 |   letters IS TEXT LIST
.br
4 | PROCEDURE:
.br
5 |   PUSH "L" TO letters
.br
6 |   PUSH "D" TO letters
.br
7 |   PUSH "P" TO letters
.br
8 |   PUSH "L" TO letters
.br
9 |   FOR EACH letter IN letters DO
.br
10|     DISPLAY letter
.br
11|   REPEAT
.br
12|   # Will display "LDPL"
.br

.B Example 2:

1 | DATA:
.br
2 |   number IS NUMBER
.br
3 |   numbers IS NUMBER MAP
.br
4 | PROCEDURE:
.br
5 |   STORE 1 IN numbers:"One"
.br
6 |   STORE 2 IN numbers:"Two"
.br
7 |   STORE 3 IN numbers:"Three"
.br
8 |   FOR EACH number IN numbers DO
.br
9 |     DISPLAY number
.br
10|   REPEAT
.br
11|   # Will display "312" or any permutation
.br



.SH BREAK

The 'BREAK' statement breaks the execution of the innermost 'WHILE' or 'FOR' loop. Will throw a compiler error if used outside one.

.B Syntax:

1 | BREAK
.br



.SH CONTINUE

The 'CONTINUE' statement jumps to the next iteration of the innermost 'WHILE' or 'FOR' loop. Will throw a compiler error if used outside one.

.B Syntax:

1 | CONTINUE
.br



.SH CALL SUB-PROCEDURE

The 'CALL SUB-PROCEDURE' statement executes a SUB-PROCEDURE. Once the SUB-PROCEDURE returns, the execution continues from the line following the 'CALL SUB-PROCEDURE'.

.B Syntax:

1 | CALL SUB-PROCEDURE <sub-procedure name>
.br
2 | CALL SUB-PROCEDURE <sub-procedure name> WITH <multiple NUMBER, TEXT, TEXT-VAR, NUMBER-VAR, MAP or LIST>
.br

or just

1 | CALL <sub-procedure name>
.br
2 | CALL <sub-procedure name> WITH <multiple NUMBER, TEXT, TEXT-VAR, NUMBER-VAR, MAP or LIST>
.br

Of course, a SUB-PROCEDURE must be declared somewhere in your program if you call it.

If the SUB-PROCEDURE you call doesn't have declared parameters, you must call it without the 'WITH' keyword, otherwise you must include it and after it pass all the parameters in the same order declared in the 'PARAMETERS' section of the SUB-PROCEDURE. Remember that variables are passed by reference, see the SUB-PROCEDUREs documentation for more details.



.SH RETURN

The 'RETURN' statement returns from a SUB-PROCEDURE. Will throw a compiler error if used outside one.

.B Syntax:

1 | RETURN
.br



.SH EXIT

The 'EXIT' statement ends execution of the program.

.B Syntax:

1 | EXIT
.br





.SH WAIT - MILLISECONDS

The 'WAIT' statement pauses the execution of a program for the given number of milliseconds.

.B Syntax:

1 | WAIT <NUMBER or NUMBER-VAR> MILLISECONDS
.br





.SH GOTO & LABEL

> "If you want to go somewhere, goto is the best way to get there."
> -- Ken Thompson

The 'GOTO' statement performs a one-way transfer of control to a line of code marked by a 'LABEL' statement. In lame man terms, the execution jumps to the line where the wanted 'LABEL' is found and continues from there.

While maligned by Edsger W. Dijkstra and his cohorts, 'GOTO' is very useful in many situations. Its reputation is undeserved and mostly perpetuated by people that don't understand the origins of the criticism or how the statement can be used.

You also can't make a COBOL_esque language without 'GOTO', so (due to popular request) here we've added it to the language.

.B Syntax:

1 | LABEL <labelName>
.br

1 | GOTO <labelName>
.br

-- Note:
.br
Label names follow the naming rules stated here.
.br
--

.B Example:

1 | PROCEDURE:
.br
2 | GOTO start
.br
3 | 
.br
4 | LABEL start
.br
5 | display "> starting..." crlf
.br
6 | 
.br
7 | GOTO ending
.br
8 | 
.br
9 | LABEL middle
.br
10| display "> entering the middle section..." crlf
.br
11| 
.br
12| sub-procedure cool-code
.br
13|     GOTO cool
.br
14|     display "hmm... is this cool?" crlf
.br
15|     LABEL cool
.br
16|     display "wow, yeah! cool code!" crlf
.br
17| end sub-procedure
.br
18| 
.br
19| LABEL ending
.br
20| CALL cool-code
.br
21| display "> that's the end" crlf
.br

In the output of this program you can see the 'middle' LABEL and the start of the 'cool-code' SUB-PROCEDURE are skipped:

1 | > starting...
.br
2 | wow, yeah! cool code!
.br
3 | > that's the end
.br

In order to keep 'GOTO' from turning your source into "_unmaintainable spaghetti code_", both your 'GOTO' statement and the 'LABEL' it jumps to have to be used together in the same sub-procedure or in the main code body of an LDPL program. So you can't 'goto' across sub-procedures or into them, or anything like that.



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH CREATE STATEMENT - EXECUTING

The 'CREATE STATEMENT' statement lets you add custom statements to LDPL that execute SUB-PROCEDUREs.

.B Syntax:

1 | CREATE STATEMENT <TEXT> EXECUTING <sub-procedure name>
.br

The 'TEXT' describes the new statement syntax and must contain tokens separated by whitespace. Each token can be a keyword, which is a word with 'A-Z' characters (preferably in English), or '"$"', a character that marks where parameters are passed. At least one keyword token is required and the number of '"$"' tokens must be the same as the number of parameters of the SUB-PROCEDURE you pass after 'EXECUTING'. For example, a valid 'TEXT' is '"DISPLAY $ $ TIMES"' if the SUB-PROCEDURE has exactly two parameters. The SUB-PROCEDURE must be declared before creating the statement.

After a statement is created you can use it like any other LDPL statement in 'PROCEDURE' sections, just write a line with all the tokens of the 'TEXT' in the same order but placing values instead of '"$"'. The types of the values must be the same as the parameter types of the SUB-PROCEDURE the statement executes following the same order. Using the new statement will produce the same effect as CALLing the SUB-PROCEDURE (parameters are passed by reference too).

You can create two different statements with same 'TEXT' and use both if at least one of the parameter types are different in each SUB-PROCEDURE, because the resulting syntaxes will differ from each other. Using this you can create two versions of the same statements dealing with different parameter types, like the first example shows.

Bear in mind that a line in your program could match more than one statement: If all of them were created with 'CREATE STATEMENT', the one that was created first will be executed. If one of the them is a LDPL built-in statement, this will be executed. For example, if you create '"DISPLAY $ $ TIMES"', declare a variable 'TIMES' and use the line 'DISPLAY "Hi!" 3 TIMES', the LDPL DISPLAY statement will be executed, because the line matches its syntax. This is illustrated in the second example.

.B Example 1:

1 | PROCEDURE:
.br
2 |   SUB-PROCEDURE displayNValueTimes
.br
3 |     PARAMETERS:
.br
4 |       value is number
.br
5 |       times is number
.br
6 |     LOCAL DATA:
.br
7 |       i is number
.br
8 |     PROCEDURE:
.br
9 |       FOR i FROM 0 TO times STEP 1 DO
.br
10|         DISPLAY value " "
.br
11|       REPEAT
.br
12|   END SUB-PROCEDURE
.br
13|   CREATE STATEMENT "DISPLAY $ $ TIMES" EXECUTING displayNValueTimes
.br
14|   # Syntax for this new statement: DISPLAY <NUMBER or NUMBER-VAR> <NUMBER or NUMBER-VAR> TIMES
.br
15| 
.br
16|   SUB-PROCEDURE displayTValueTimes
.br
17|     PARAMETERS:
.br
18|       value is text
.br
19|       times is number
.br
20|     LOCAL DATA:
.br
21|       i is number
.br
22|     PROCEDURE:
.br
23|       FOR i FROM 0 to times STEP 1 DO
.br
24|         DISPLAY value " "
.br
25|       REPEAT
.br
26|   END SUB-PROCEDURE
.br
27|   CREATE STATEMENT "DISPLAY $ $ TIMES" EXECUTING displayTValueTimes
.br
28|   # Syntax for this new statement: DISPLAY <TEXT or TEXT-VAR> <NUMBER or NUMBER-VAR> TIMES
.br
29| 
.br
30|   # We can imagine that we have only one new statement:
.br
31|   # DISPLAY <NUMBER or NUMBER-VAR or TEXT or TEXT-VAR> <NUMBER or NUMBER-VAR> TIMES
.br
32| 
.br
33|   DISPLAY 100 2 TIMES # This executes: CALL displayNValueTimes with 100 2
.br
34|   DISPLAY "Hi!" 3 TIMES # This executes: CALL displayTValueTimes with "Hi!" 3
.br
35| 
.br
36|   # This program displays "100 100 Hi! Hi! "
.br

.B Example 2:

1 | DATA:
.br
2 |   times is number
.br
3 | PROCEDURE:
.br
4 |   SUB-PROCEDURE displayTValueTimes
.br
5 |     PARAMETERS:
.br
6 |       value is text
.br
7 |       times is number
.br
8 |     LOCAL DATA:
.br
9 |       i is number
.br
10|     PROCEDURE:
.br
11|       FOR i FROM 0 to times STEP 1 DO
.br
12|         DISPLAY value " "
.br
13|       REPEAT
.br
14|   END SUB-PROCEDURE
.br
15|   CREATE STATEMENT "DISPLAY $ $ TIMES" EXECUTING displayTValueTimes
.br
16|   # Syntax for this new statement: DISPLAY <TEXT or TEXT-VAR> <NUMBER or NUMBER-VAR> TIMES
.br
17| 
.br
18|   DISPLAY "Hi!" 3 TIMES # This executes the LDPL DISPLAY statement!
.br
19| 
.br
20|   # This program displays "Hi!30" because times is equal to 0
.br



.ce 1
.SH -=-=-=-=- DOCS: ARITHMETIC STATEMENTS -=-=-=-=-

.SH IN - SOLVE

The 'IN - SOLVE' statement will solve a simple arithmetic expression and place the result in a NUMBER variable. Only '+', '-', '/', '*' operators, NUMBER values, and TEXT values can be used in a MATH-EXPRESSION. Other LDPL arithmetic functions, like CEIL and MODULO, are not supported by this statement and should be used as standalone statements. TEXT values will be implicitly converted to NUMBERs using the same algorithm as STORE - IN.

Spaces must be used to separate numbers, variables and operators.

As in actual arithmetic, '*' and '/' have higher precedence than '+' and '-' , while parens '()' can be used to group expressions.

Syntax:

1 | IN <NUMBER-VAR> SOLVE <MATH-EXPRESSION>
.br

Example:

1 | IN myNumVariable SOLVE 1 + 1
.br

Will set the value of 'myNumVariable' to '2'.

Area of Circle:

1 | DATA:
.br
2 | Radius is NUMBER
.br
3 | Area is NUMBER
.br
4 | 
.br
5 | PROCEDURE:
.br
6 | DISPLAY "Enter Radius: "
.br
7 | ACCEPT Radius
.br
8 | 
.br
9 | IN Area SOLVE 3.14159 * (Radius * Radius)
.br
10| DISPLAY "Area is: " Area CRLF
.br

Outputs:

1 | Enter Radius: 0.5
.br
2 | Area is: 0.7853975
.br



.SH FLOOR

The 'FLOOR' statement rounds down the value of NUMBER-VAR to the nearest lower integer.

.B Syntax:

1 | FLOOR <NUMBER-VAR>
.br



.SH MODULO - BY - IN

The 'MODULO' statement calculates the remainder of the modulo operation between two NUMBER values and stores the result in a NUMBER variable.

.B Syntax:

1 |  MODULO <NUMBER-VAR or NUMBER> BY <NUMBER-VAR or NUMBER> IN <NUMBER-VAR>
.br



.SH GET RANDOM IN

The 'GET RANDOM' statement stores a random value between 0 (inclusive) and 1 (noninclusive) in a NUMBER variable.

.B Syntax:

1 | GET RANDOM IN <NUMBER-VAR>
.br



.ce 1
.SH -=-=-=-=- DOCS: TEXT STATEMENTS -=-=-=-=-

.SH JOIN - AND - IN

The 'JOIN' statement concatenates two values and stores them in a TEXT variable. If any value is a number, it is converted to a string before concatenation.

.B Syntax:

1 | JOIN <NUMBER-VAR or NUMBER or TEXT-VAR or TEXT> AND <NUMBER-VAR or NUMBER or TEXT-VAR or TEXT> IN <TEXT-VAR>
.br

Type Conversion Note:

If any of the values to be joined is a NUMBER value, the value will be converted to text, so '15' will be turned into '"15"' and '-19.2' into '"-19.2"'.



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH REPLACE - FROM - WITH - IN

The 'REPLACE' statement finds and replaces every occurrence of some TEXT in a TEXT variable or value some other TEXT. The result is then stored in a TEXT variable.

Syntax:

1 | REPLACE <TEXT-VAR or TEXT> FROM <TEXT-VAR or TEXT> WITH <TEXT-VAR or TEXT> IN <TEXT-VAR>
.br

Example:

1 | REPLACE "COBOL" FROM "COBOL is great!" WITH "LDPL" IN sentiment
.br
2 | DISPLAY sentiment crlf
.br

Outputs:

1 | LDPL is great!
.br



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH SPLIT - BY - IN

The 'SPLIT' statement breaks up a single TEXT variable into multiple parts based on another TEXT variable and puts those parts into sub-indexes of a 'TEXT LIST', starting at the NUMBER '0' and incrementing by whole numbers. This allows you to break up a text sentence into multiple parts by splitting on spaces, for example. Or to split a file into lines by splitting on '"\\n"'

To break TEXT into individual characters, split by the empty string of '""'.

Syntax:

1 | SPLIT <TEXT-VAR or TEXT> BY <TEXT-VAR or TEXT> IN <TEXT-LIST>
.br

Example:

1 | DATA:
.br
2 |   parts IS TEXT LIST
.br
3 | PROCEDURE:
.br
4 |   SPLIT "Hello there!" BY " " IN parts
.br
5 |   display parts:0 crlf parts:1 crlf
.br

will output:

1 | Hello
.br
2 | there!
.br

Split into characters:

1 | DATA:
.br
2 |   parts IS TEXT LIST
.br
3 | PROCEDURE:
.br
4 |   SPLIT "onomatopoeia" BY "" IN parts
.br
5 |   DISPLAY parts:3 " is M " crlf
.br

will output:

1 | m is M
.br



.SH GET CHARACTER AT - FROM - IN

The 'GET CHARACTER AT' statement gets the character at the position indicated by the NUMBER value from the TEXT value and stores it in a TEXT variable.

.B Syntax:

1 | GET CHARACTER AT <NUMBER-VAR or NUMBER> FROM <TEXT-VAR or TEXT> IN <TEXT-VAR>
.br



.SH GET LENGTH OF - IN

The 'GET LENGTH OF' statement counts the number of characters in the passed TEXT and stores that number in the NUMBER variable.

.B Syntax:

1 | GET LENGTH OF <TEXT-VAR or TEXT> IN <NUMBER-VAR>
.br





.SH GET ASCII CHARACTER - IN

The 'GET ASCII CHARACTER' statement stores the character with the ASCII code passed in NUMBER or NUMBER-VAR in TEXT-VAR.

.B Syntax:

1 | GET ASCII CHARACTER <NUMBER or NUMBER-VAR> IN <TEXT-VAR>
.br



.SH GET CHARACTER CODE OF - IN

The 'GET CHARACTER CODE OF' statement stores the ASCII code of the character passed in TEXT or TEXT-VAR in NUMBER-VAR. Will fail if the length of the string passed in TEXT or TEXT-VAR is not 1.

.B Syntax:

1 | GET CHARACTER CODE OF <TEXT or TEXT-VAR> IN <NUMBER-VAR>
.br

.B Error codes:

Multi-byte characters (like emojis and non-ASCII characters) cannot be parsed by this statement. When trying to do so, the operation will fail and the following values will be returned into the 'ERRORCODE' and 'ERRORTEXT' variables:

.br
[*] 'ERRORCODE': 1
.br
[*] 'ERRORTEXT': "Multibyte character received (probably UTF-8). Can't be parsed into a single number."

-- Warning:
.br
Always use the 'ERRORCODE' variable to check if the operation was successful or not. Do not use 'ERRORTEXT' for anything else than displaying the error found, as its contents may change in future releases of LDPL.
.br
--



.SH STORE QUOTE - IN

The 'STORE QUOTE IN' statement allows you to store multiple lines in a single TEXT variable. Between the 'STORE QUOTE IN' and 'END QUOTE' statements whitespace is preserved literally, escape codes like '\\t' and '\\e' work the same as they do in regular text variables (and can themselves be escaped using '\\\\'), and double quotes ('"') don't need to be escaped.

Syntax:

1 | STORE QUOTE IN <TEXT-VAR>
.br
2 |   #Text goes here
.br
3 | END QUOTE
.br

Example:

1 | DATA:
.br
2 | template IS TEXT
.br
3 | 
.br
4 | PROCEDURE:
.br
5 | STORE QUOTE IN template
.br
6 | <html>
.br
7 |     <head><title>{{title}}</title></head>
.br
8 |     <body>{{body}}</body>
.br
9 | </html>
.br
10| END QUOTE
.br
11| 
.br
12| # ...code to use the template...
.br



.SH IN - JOIN

The 'IN JOIN' statement concatenates two or more values and stores them in a TEXT variable. If any of those values is a number, it is converted to a string before concatenation.

.B Syntax:

1 | IN <TEXT-VAR> JOIN <multiple NUMBER, TEXT, TEXT-VAR, NUMBER-VAR or CRLF>
.br

.B Example:

1 | IN myTextVariable JOIN "Hello World!" " " "Welcome to LDPL!" crlf
.br

will store

1 | "Hello World! Welcome to LDPL!\\n"
.br

in 'myTextVariable'.



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH GET INDEX OF - FROM - IN

The 'GET INDEX OF - FROM - IN' statement stores in a NUMBER variable the position of the first occurrence of a specified value in a string or TEXT variable. The first position of a string (the first letter) is considered to be the position number '0'. The value '-1' is stored if there are no occurrences.

.B Syntax:

1 | GET INDEX OF <TEXT or TEXT-VAR> FROM <TEXT or TEXT-VAR> IN <NUMBER-VAR>
.br

.B Example:

1 | DATA:
.br
2 |   position IS NUMBER
.br
3 | PROCEDURE:
.br
4 |   GET INDEX OF "is" FROM "LDPL is nice!" IN position
.br
5 |   DISPLAY position CRLF
.br
6 |   # Will display 5.
.br



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH COUNT - FROM - IN

The 'COUNT - FROM - IN' statement counts all the appearances of a string in another string and stores that value in a NUMBER variable.

.B Syntax:

1 | COUNT <TEXT or TEXT-VAR> FROM <TEXT or TEXT-VAR> IN <NUMBER-VAR>
.br

.B Example:

1 | DATA:
.br
2 |   count IS NUMBER
.br
3 | PROCEDURE:
.br
4 |   COUNT "the" FROM "the cat is called theodore" IN count
.br
5 |   DISPLAY count CRLF
.br
6 |   # Will display 2, as the can be found two times in that sentence.
.br





---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH SUBSTRING - FROM - LENGTH - IN

The 'SUBSTRING - FROM - LENGTH - IN' statement extracts parts of a string, beginning at the character at the specified position and storing in the destination TEXT variable the specified number of characters.

.B Syntax:

1 | SUBSTRING <TEXT or TEXT-VAR> FROM <NUMBER or NUMBER-VAR> LENGTH <NUMBER or NUMBER-VAR> IN <TEXT-VAR>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT
.br
3 | PROCEDURE:
.br
4 |   SUBSTRING "Hello there!" FROM 1 LENGTH 4 IN foo
.br
5 |   # This will extract 4 characters from position 1
.br
6 |   DISPLAY foo CRLF
.br
7 |   # Will display "ello"
.br





---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH TRIM - IN

The 'TRIM - IN' statement removes whitespace from both sides of a string and stores the resulting string in a TEXT variable.

.B Syntax:

1 | TRIM <TEXT or TEXT-VAR> IN <TEXT-VAR>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT
.br
3 | PROCEDURE:
.br
4 |   TRIM "        hello there!            " IN foo
.br
5 |   DISPLAY foo CRLF
.br
6 |   # Will display "hello there!"
.br





.ce 1
.SH -=-=-=-=- DOCS: LIST STATEMENTS -=-=-=-=-

---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH PUSH - TO

The 'PUSH - TO' statement is used to add elements to a LIST. When you push an element to a LIST it is appended at the end of the list.

.B Syntax:

1 | PUSH <NUMBER-VAR or NUMBER> TO <NUMBER-LIST>
.br
2 | PUSH <TEXT-VAR or TEXT> TO <TEXT-LIST>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT LIST
.br
3 | PROCEDURE:
.br
4 |   PUSH "First index" TO foo
.br
5 |   PUSH "Second index" TO foo
.br

In the above example, 'foo' now contains the value '"First index"' at index '0' and the value '"Second index"' at index '1'.



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH CLEAR

The 'CLEAR' statement empties a LIST, thus deleting all its contents. The LIST itself is not deleted though, and can still be used and filled with new elements after a 'CLEAR' statement has been executed.

.B Syntax:

1 | CLEAR <LIST>
.br



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH COPY - TO

The 'COPY - TO' statement copies all the elements of a LIST with their respective indices to another LIST of the same type. The original LIST is untouched, but the destination LIST is completely overwritten by the contents of the copied LIST and any elements that existed in it prior to the copy are deleted. In other words, the destination LIST is CLEARed before the copy.

.B Syntax:

1 | COPY <TEXT-LIST> TO <TEXT-LIST>
.br
2 | COPY <NUMBER-LIST> TO <NUMBER-LIST>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT LIST
.br
3 |   bar IS TEXT LIST
.br
4 | PROCEDURE:
.br
5 |   PUSH "Hello there!" TO foo
.br
6 |   PUSH "How are you?" TO foo
.br
7 |   COPY foo TO bar
.br
8 |   DISPLAY bar:0 " " bar:1 CRLF
.br
9 |   # Will display "Hello there! How are you?"
.br



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH GET LENGTH OF - IN

The 'GET LENGTH OF - IN' statement stores the amount of elements stored in a LIST (or, analogously, the length of the LIST) into a numeric variable.

.B Syntax:

1 | GET LENGHT OF <LIST> IN <NUMBER-VAR>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT LIST
.br
3 |   count IS NUMBER
.br
4 | PROCEDURE:
.br
5 |   PUSH "Hello there!" TO foo
.br
6 |   PUSH "How are you?" TO foo
.br
7 |   STORE LENGTH OF foo IN count
.br
8 |   DISPLAY count CRLF
.br
9 |   # Will display 2
.br



---
description: Introduced in LDPL 3.1.0 - Diligent Dreadnoughtus
---

.SH DELETE LAST ELEMENT OF

The 'DELETE LAST ELEMENT OF' deletes the last element pushed to a LIST. If the LIST was empty, this statement does nothing.

.B Syntax:

1 | DELETE LAST ELEMENT OF <LIST>
.br



.ce 1
.SH -=-=-=-=- DOCS: MAP STATEMENTS <A ID="VECTOR-STATEMENTS"></A> -=-=-=-=-

---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH CLEAR

The 'CLEAR' statement empties a MAP, thus deleting all its contents. The MAP itself is not deleted though, and can still be used and filled with new elements after a 'CLEAR' statement has been executed.

.B Syntax:

1 | CLEAR <MAP>
.br



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH COPY - TO

The 'COPY - TO' statement copies all the elements of a MAP with their respective keys to another MAP of the same type. The original MAP is untouched, but the destination MAP is completely overwritten by the contents of the copied MAP and any elements that existed in it prior to the copy are deleted. In other words, the destination MAP is CLEARed before the copy.

.B Syntax:

1 | COPY <TEXT-MAP> TO <TEXT-MAP>
.br
2 | COPY <NUMBER-MAP> TO <NUMBER-MAP>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT MAP
.br
3 |   bar IS TEXT MAP
.br
4 | PROCEDURE:
.br
5 |   STORE "Hello there!" IN foo:0
.br
6 |   STORE "How are you?" IN foo:7
.br
7 |   COPY foo TO bar
.br
8 |   DISPLAY bar:0 " " bar:7 CRLF
.br
9 |   # Will display "Hello there! How are you?"
.br



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH GET KEY COUNT OF - IN

The 'GET KEY COUNT OF - IN' statement stores the amount of elements (or, analogously, keys) stored in a MAP into a numeric variable.

.B Syntax:

1 | GET KEY COUNT OF <MAP> IN <NUMBER-VAR>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT MAP
.br
3 |   count IS NUMBER
.br
4 | PROCEDURE:
.br
5 |   STORE "Hello there!" IN foo:0
.br
6 |   STORE "How are you?" IN foo:7
.br
7 |   GET KEY COUNT OF foo IN count
.br
8 |   DISPLAY count CRLF
.br
9 |   # Will display 2
.br



---
description: Introduced in LDPL 3.0.5 - Creative Carnotaurus
---

.SH GET KEYS OF - IN

The 'GET KEYS OF - IN' statement stores all the keys of a MAP into a TEXT LIST. Say you have a MAP with keys '0', '"cat"' and '"dog"'. The elements these keys point to are not important. Using the 'GET KEYS OF' statement, you can copy the keys of this MAP to a LIST. Thus, the resulting LIST will (for example) have the value '0' at index 0, the value '"cat"' at index 1 and the value '"dog"' at index 2. This statement is thus used to find all the keys of a particular MAP.

.B Syntax:

1 | GET KEYS OF <MAP> IN <TEXT-LIST>
.br

.B Example:

1 | DATA:
.br
2 |   foo IS TEXT MAP
.br
3 |   bar IS TEXT LIST
.br
4 | PROCEDURE:
.br
5 |   STORE "Hello there!" IN foo:0
.br
6 |   STORE "How are you?" IN foo:7
.br
7 |   STORE "I like cats" IN foo:"cat"
.br
8 |   STORE "I love dogs" IN foo:"dog"
.br
9 |   STORE "LDPL is nice" IN foo:3
.br
10|   GET KEYS OF foo IN bar
.br

At the end of the execution of the previous excerpt of code, the 'TEXT LIST' called 'bar' will contain the values '"0"', '"7"', '"cat"', '"dog"' and '"3"' at indexes that are consecutive integers starting at zero.



.ce 1
.SH -=-=-=-=- DOCS: I/O STATEMENTS -=-=-=-=-

.SH DISPLAY

The 'DISPLAY' statement outputs the values passed to the output stream. 'CRLF' means line break and is a sugar syntax for the '"\\n"' escape sequence.

.B Syntax:

1 | DISPLAY <multiple NUMBER, TEXT, TEXT-VAR, NUMBER-VAR or CRLF>
.br

.B Example:

1 | DISPLAY "Hello, " nameVariable "! This is a number -> " 89.1 " :)" CRLF
.br



.SH ACCEPT

The 'ACCEPT' command is used to gather input from the user. If a TEXT variable is specified, anything the user enters before pressing the 'return' key will be accepted. If a NUMBER variable is specified, the user must enter a number (if any non-numeric key is entered, the error message "Redo from start" will be output and the ACCEPT command rerun).

.B Syntax:

1 | ACCEPT <TEXT-VAR or NUMBER-VAR>
.br





.SH EXECUTE

The 'EXECUTE' statement executes the specified system command.

.B Syntax:

1 | EXECUTE <TEXT or TEXT-VAR>
.br

.B Example 1:

1 | # Prepare the command to execute
.br
2 | IN myTextVar JOIN "echo " myVariable " >> myFile"
.br
3 | # Execute it
.br
4 | EXECUTE myTextVar
.br

.B Example 2:

1 | # Execute "dir" to list the files in the current directory under Windows
.br
2 | EXECUTE "dir"
.br



.SH EXECUTE - AND STORE OUTPUT IN

The 'EXECUTE - AND STORE OUTPUT IN' executes the specified command and stores any resulting text in the passed variable.

.B Syntax:

1 | EXECUTE <TEXT or TEXT-VAR> AND STORE OUTPUT IN <TEXT-VAR>
.br



.SH EXECUTE - AND STORE EXIT CODE IN

The 'EXECUTE - AND STORE EXIT CODE IN' executes the specified command and stores the exit code in the passed variable.

.B Syntax:

1 | EXECUTE <TEXT or TEXT-VAR> AND STORE EXIT CODE IN <NUM-VAR>
.br



.SH ACCEPT - UNTIL EOF

The 'ACCEPT UNTIL EOF' statement accepts input from standard input until an EOF state is reached and stores all data gathered in TEXT-VAR.

.B Syntax:

1 | ACCEPT <TEXT-VAR> UNTIL EOF
.br





.SH LOAD FILE - IN

The 'LOAD FILE' statement loads the contents of a file into a text variable.

.B Syntax:

1 | LOAD FILE <TEXT or TEXT-VAR> IN <TEXT-VAR>
.br

.B Example:

1 | LOAD FILE "myFolder/myTextFile.txt" IN myVariable
.br

.B Error codes:

If the LOAD operation should fail, the following values will be returned into the 'ERRORCODE' and 'ERRORTEXT' variables:

.br
[*] 'ERRORCODE': 1
.br
[*] 'ERRORTEXT': "The file '<filename>' couldn't be opened."

-- Warning:
.br
Always use the 'ERRORCODE' variable to check if the operation was successful or not. Do not use 'ERRORTEXT' for anything else than displaying the error found, as its contents may change in future releases of LDPL.
.br
--



.SH WRITE - TO FILE

The 'WRITE x TO FILE y' statement writes the value of 'x' to the file called 'y'. If the file already exists, everything in it will be overwritten by 'x'.

.B Syntax:

1 | WRITE <NUMBER or NUMBER-VAR or TEXT or TEXT-VAR> TO FILE <TEXT or TEXT-VAR>
.br

.B Example:

1 | WRITE "Hello there!" TO FILE "hello.txt"
.br



.SH APPEND - TO FILE

The 'APPEND x TO FILE y' statement appends the value of 'x' to the file called 'y'. If the file already exists, 'x' will be added at the end of its contents.

.B Syntax:

1 | APPEND <NUMBER or NUMBER-VAR or TEXT or TEXT-VAR> TO FILE <TEXT or TEXT-VAR>
.br

.B Example:

1 | APPEND "\\nHow are you?" TO FILE "hello.txt"
.br

in this case, the file 'hello.txt', created here and modified as stated on that page, will contain the text

1 | Hello there!
.br
2 | How are you?
.br



.ce 1
.SH -=-=-=-=- DOCS: EXTENSIONS -=-=-=-=-

.SH C++ EXTENSIONS

Extensions contain SUBPROCEDUREs and VARIABLEs that are written in another language and usable in LDPL through the CALL EXTERNAL statement and EXTERNAL data type keyword. This allows programmers to extend LDPL with new features or to wrap 3rd party libraries and re-use their functionality.

Starting with release 3.0.0, LDPL supports extensions written in C++. Because LDPL programs compile down to C++, there is no need for a translation layer or bridge: extensions can be included directly into LDPL programs and manipulate, share, and access subprocedures and variables natively. All that's needed is a few naming conventions on the C++ side and the use of the 'EXTERNAL' syntax for variables and subprocedures on the LDPL side.

-- Note:
.br
Check out the "Hello World" for a quick example.
.br
--





.SH WRITING C++ EXTENSIONS

Extensions can create variables and functions that are accessible from LDPL through the CALL EXTERNAL statement and EXTERNAL data type keyword. Typically all you need is a single '.cpp' file that you give the 'ldpl' compiler when building your program, but you can also use '.o' files, '.a' files, or any combination of them all.

Extensions interact with LDPL in two main way: defining functions and declaring variables.

.B Functions

To create a function in C++ that can be called from an LDPL program, you must follow two rules:

1. The function's type must be 'void(void)', ex: 'void MY_FUNC();'
2. The function's name must conform to LDPL's Extension Naming Convention.

Because LDPL functions don't accept arguments or return values, to be callable from LDPL your C++ functions musn't either.

And because LDPL doesn't "know" the names of your functions and instead allows the programmer to call them using the 'EXTERNAL' syntax, all C++ variable and subprocedure names must contain only 'A-Z', '0-9', and the '_' character. Everything else on the LDPL side will get converted to an underscore ('_') when referencing the C++ side.

.B Example

For example, this function:

1 | void PROMPT_ADD()
.br
2 | {
.br
3 |   int a, b, sum;
.br
4 |   cout << "1st number: ";
.br
5 |   cin >> a;
.br
6 |   cout << "2nd number: ";
.br
7 |   cin >> b;
.br
8 |   cout << "sum: " << sum << end;
.br
9 | }
.br

Once defined and built into LDPL, can be called using:

1 | CALL EXTERNAL prompt-add
.br

.B Variables

To create or reference a variable in a C++ extension that is shared with an LDPL program, you must follow two rules:

1. The variable's name must conform to LDPL's Extension Naming Convention.
2. The C++ type of the variable must match LDPL's internal type usage.

The first rule should be familiar from the functions section: all C++ variable and subprocedure names must contain only 'A-Z', '0-9', and the '_' character. Everything else on the LDPL side will get converted to an underscore ('_').

For the second, here's the mapping between types:

.br
| LDPL Data Type | C++ Type |
.br
| :--- | :--- |
.br
| 'TEXT' | 'std::string' |
.br
| 'NUMBER' | 'ldpl_number' |
.br
| 'TEXT MAP' | 'ldpl_vector<std::string>' |
.br
| 'NUMBER MAP' | 'ldpl_vector<ldpl_number>' |
.br
| 'TEXT LIST' | 'ldpl_list<std::string>' |
.br
| 'NUMBER LIST' | 'ldpl_list<ldpl_number>' |

The declarations for this data types are included when your C++ code merged with LDPL code by the LDPL compiler.

.B Example

Declaring 'TEXT'and 'NUMBER' variables is easy on the C++ side:

1 | std::string NAME;
.br
2 | ldpl_number AGE;
.br
3 | std::string STREET_ADDRESS;
.br

These will be available to an LDPL program to declare in its 'DATA:' section:

1 | DATA:
.br
2 | name IS EXTERNAL TEXT
.br
3 | age IS EXTERNAL NUMBER
.br
4 | street-address IS EXTERNAL TEXT
.br

.B Accessing Variables in Functions

Since LDPL and C++ are using the same variable when you use the 'EXTERNAL' keyword, any changes you make to the variable's content are shared. Just use them like you would use regular C++ variables.

1 | ldpl_number A, B, SUM;
.br
2 | void ADD()
.br
3 | {
.br
4 |     SUM = A + B;
.br
5 | }
.br

1 | DATA:
.br
2 | A IS EXTERNAL NUMBER
.br
3 | B IS EXTERNAL NUMBER
.br
4 | SUM IS EXTERNAL NUMBER
.br
5 | 
.br
6 | PROCEDURE:
.br
7 | STORE 100 IN A
.br
8 | STORE 250 IN B
.br
9 | CALL EXTERNAL add
.br
10| DISPLAY SUM CRLF
.br

Building and running this program will print '350'.

.B LDPL MAPs

The 'MAP' types are a bit trickier - they are defined as 'ldpl_vector<T>', so you'll want to declare this prototype in your '.cpp' or '.h' file to use it in your extension:

1 | #ifndef ldpl_vector
.br
2 | template<typename T>
.br
3 | struct ldpl_vector {
.br
4 |     T& operator [] (const std::string& i);
.br
5 |     T& operator [] (double i);
.br
6 | };
.br
7 | #endif
.br

Now you can use MAPs in LDPL:

1 | DATA:
.br
2 | Names IS EXTERNAL TEXT MAP
.br

And in C++:

1 | ldpl_vector<std::string> NAMES;
.br
2 | 
.br
3 | // later...
.br
4 | NAMES[0] = "Pauline"
.br
5 | NAMES[1] = "just Paul"
.br

-- Note:
.br
The internal datatype for LDPL MAPs is called ldpl\\_vector because in LDPL releases prior to LDPL 3.1.0 Diligent Dreadnoughtus, MAPs where called VECTORs.
.br
--



.SH BUILDING C++ EXTENSIONS

Extensions are easy to build: when compiling your LDPL program, use the '-i=' flag to pass in '.cpp' files, '.o' files, or '.a' files to the LDPL compiler. They'll get included in your program and be available using the 'EXTERNAL' statements.

For example, if your LDPL source file is called 'mySource.ldpl' and you want to include 'otherFile.cpp' to your project, you just do

1 | $ ldpl -i=otherFile.cpp mySource.ldpl
.br

Starting from LDPL 4.0, you can also use the 'EXTENSION' statement to include extensions to your project, just like you'd use the INCLUDE statement to include LDPL source files:

1 | EXTENSION "myExtension.cpp"
.br
2 | 
.br
3 | procedure:
.br
4 |   call external someFunction
.br

The location where extensions are searched when using the 'EXTENSION' statement is relative to the file that includes them.

If your C++ extension files require extra flags to be passed to the C++ compiler in order to compile (for example, '-lSDL' when working with SDL) you can use the '-f=' flag to pass those flags to it. Following the SDL example, you could do

1 | $ ldpl -i=mySDLSource.cpp mySource.ldpl -f=-lSDL
.br

and the C++ compiler will be executed with the '-lSDL' flag.

1 | $ ldpl -i=<extension file> code.ldpl
.br

Starting from LDPL 4.0, you can also use the 'FLAG' statement to pass flags to the C++ compiler:

1 | EXTENSION "myExtension.cpp"
.br
2 | FLAG "-fpermissive" # This is the same as passing -f=-fpermissive to the LDPL compiler.
.br
3 | FLAG "-lSDL2" # This is the same as passing -f=-lSDL2 to the LDPL compiler.
.br
4 | 
.br
5 | procedure:
.br
6 |   call external someFunction
.br





.SH EXTERNAL IDENTIFIER NAMING SCHEME

All C++ variable and functions accessible to LDPL programs must contain only 'A-Z', '0-9',  and the '_' character in their names. All other characters used on the LDPL side to reference the variable or function will get converted to an underscore ('_') or, if it's a letter, capitalized.

LDPL => C++ Conversion Examples

.br
| LDPL Identifier | C++ Identifier |
.br
| :--- | :--- |
.br
| window.rows | WINDOW\\_ROWS |
.br
| HTTP/get | HTTP\\_GET |
.br
| SDL/Font.new | SDL\\_FONT\\_NEW |
.br
| sdl.font-new | SDL\\_FONT\\_NEW |
.br
| NAME | NAME |
.br
| version\\_number | VERSION\\_NUMBER |

-- Warning:
.br
Note that this conversion scheme can cause collisions: all of these LDPL variables will convert to 'ONE_TWO:'

.br
[*] 'One-Two'
.br
[*] 'one.two'
.br
[*] 'one/two'
.br
[*] 'OnE-TWO'
.br
--



.SH "HELLO WORLD" C++ EXAMPLE

File: simple.cpp
.br
1 | #include <iostream>
.br
2 | void SIMPLE(){
.br
3 |         std::cout << "Very simple!" << std::endl;
.br
4 | }
.br


File: simple.ldpl
.br
1 | PROCEDURE:
.br
2 | CALL EXTERNAL simple
.br
3 | 
.br


1 | $ ldpl -i=simple.cpp simple.ldpl
.br
2 | LDPL: Compiling...
.br
3 | * File(s) compiled successfully.
.br
4 | * Saved as simple-bin
.br
5 | $ ./simple-bin
.br
6 | Very simple!
.br





.SH MORE EXAMPLES

.br
| Project | Description | Why an extension? |
.br
| :--- | :--- | :--- |
.br
| GILD | Gopher client in LDPL | Uses sockets to make TCP requests. |
.br
| LDPLNOISE | Linenoise (readline) for LDPL | Wraps linenoise C++ library. |





.SH CALL EXTERNAL

The 'CALL EXTERNAL' statement executes a SUB-PROCEDURE defined in an extension to LDPL, typically in C++. It otherwise operates the same as 'CALL SUB-PROCEDURE', except that external SUB-PROCEDURES do not receive parameters.

.B Syntax:

1 | CALL EXTERNAL <external sub-procedure name>
.br

Example:

1 | CALL EXTERNAL http-get
.br





.SH EXTERNAL SUB-PROCEDURES

Sometimes when writting C++ Extensions you'll find yourself in the need of declaring a function in C++ but coding it in LDPL. This is the opposite of writing C++ functions and calling them from LDPL, it's writing LDPL SUB-PROCEDUREs and calling them from C++.

These C++ calleable SUB-PROCEDUREs are called EXTERNAL SUB-PROCEDUREs, as they can be called from an EXTERNAL medium.

In order to declare an EXTERNAL SUB-PROCEDURE you must first declare it in your C++ source code. Say, for example, that you want to declare a SUB-PROCEDURE called 'helloWorld'. In your C++ you should write the following line:

1 | void HELLOWORLD();
.br

Note that EXTERNAL SUB-PROCEDUREs cannot receive any kind of parameters and must be declared as 'void'. You may then call the EXTERNAL SUB-PROCEDURE from C++ code like:

1 | int myCPPFunction(){
.br
2 |   HELLOWORLD();
.br
3 |   return 1;
.br
4 | }
.br

Once that's taken care of, you can declare your EXTERNAL SUB-PROCEDURE as any other SUB-PROCEDURE in LDPL by preppending the identifier EXTERNAL to the SUB-PROCEDURE declaration:

1 | EXTERNAL SUB-PROCEDURE helloWorld #or EXTERNAL SUB
.br
2 |   #Code here...
.br
3 | END SUB-PROCEDURE
.br

These SUB-PROCEDUREs can be called from LDPL as any other SUB-PROCEDURE, but their names must follow the External Identifier Naming Scheme as any other C++ interfacing component.



.SH EXTERNAL VARIABLES

Variables defined in extensions can be accessed by prefacing their data type declaration with the 'EXTERNAL' keyword. This must occur in the DATA section of an LDPL program. Once an external variable is declared, it can be used just like any other LDPL variable.

.B Syntax:

1 | <variable> IS EXTERNAL <data type>
.br

Example:

1 | DATA:
.br
2 | RL-PROMPT IS EXTERNAL TEXT
.br
3 | WINDOW.SIZE IS EXTERNAL NUMBER
.br




